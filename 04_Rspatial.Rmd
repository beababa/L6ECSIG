---
title: "R spatial"
author: "B. Maranget"
date: "06/03/2025"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Objet

R spatial avec la librairie sf (traitement des objets géographiques) et mapsf (cartographie)


sources :

- https://r-spatial.github.io/sf/

- https://riatelab.github.io/mapsf/

Ne pas oublier les cheat_sheet

- https://riatelab.github.io/mapsf/articles/web_only/cheat_sheet.html# Objets R spatiaux : le dataframe sf

- https://github.com/rstudio/cheatsheets/blob/main/sf.pdf

# Import


```{r}
library(sf)
library(mapsf)
cadastre <- st_read("data/cadastre-93010-parcelles.json")
# quel contenu pour le fichier ?
str(cadastre)
# carte
mf_map(cadastre)
mf_layout("Cadastre de Bondy", "cadastre.data.gouv\n2025")
```


# Indexation

Regarder l'indexation du dataframe dans la partie base R.
Sélectionner le premier bureau et l'afficher.
Quelle est la différence ?


```{r}
table(cadastre$section)
sel <- cadastre [cadastre$section == "A",]
mf_map(sel)
mf_layout("Cadastre de Bondy, section A", "cadastre.data.gouv\n2025")
```


# Operations géométriques

Fusion des sections, trouver la fonction et l'appliquer en s'inspirant de l'article 3 du github sf


```{r}
# première solution
fusion <- st_union(sel)
str(fusion)
plot(fusion)
# deuxième solution
enveloppe <- st_convex_hull(fusion)
plot(enveloppe)
# troisième solution
tampon <- st_buffer(sel, 50)
plot(tampon$geom)
fusion <- st_union(tampon)
plot(fusion)
#simplifier <- st_simplify(fusion,90, preserveTopology = T)
#plot(simplifier)
```


# Première carte



```{r}
# carte avec commande rbase
str(sel)
sel$aire <- st_area(sel$geometry)
mf_map(sel, type = "choro", pal = "Burg",
       border = NA, var = "aire")
```


# Jointure attributaire


Mettre un lien entre le cadastre et la valeur foncière

```{r}
vf <- read.csv("data/vf_93.csv", fileEncoding = "UTF-8", dec = ",")
```



## Les clés

```{r}
cadastre$section
cadastre$numero
vf$cle
```

### Comment recoder pour faire correspondre les clés ?

La clé du cadastre est de type : section & numero
Celle des vf est de type : cle

Il faut donc concaténer pour créer la clé du cadastre


### Faire l'algo de la jointure


- pour clé cadastre, concaténer les champs section et numéro

- pour les vf, filtrer sur Bondy

- pour clé vf, reprendre le champs clé

- vérifier si clé cadaste et clé vf correspondent

- jointure attributaire zone et chiffres

- sauvegarder le résultat de la jointure

### Donner les fonctions R

- as.integer

- merge pour le jonction attributaire

### Faire le script

```{r}
vfBondy <- vf [vf$ville == "BONDY",]
cadastre$cle <- paste0(cadastre$section, cadastre$numero)
jointure <- merge(cadastre, vfBondy, by = "cle")
st_write(jointure, "data/bondy.gpkg", "jointure", delete_layer = T)
```


# Carte des résultats

```{r}
library(sf)
library(mapsf)
summary(jointure$nb)
mf_map(cadastre, border = NA, col = "wheat")
mf_map(jointure, type = "choro", var = "nb", add = T)
mf_layout("Nb de transactions", "data.gouv\n2025")

```

